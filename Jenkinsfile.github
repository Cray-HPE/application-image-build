/*
 *
 *  MIT License
 *
 *  (C) Copyright 2022 Hewlett Packard Enterprise Development LP
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *  OTHER DEALINGS IN THE SOFTWARE.
 *
 */
@Library('csm-shared-library') _

// Release toggles; define stable, and when to rebuild from a stable branch.
def promotionToken = ~"(master|main|develop|lts\\/.*)"
def buildAndPublish = env.TAG_NAME == null && !(env.BRANCH_NAME ==~ promotionToken) ? true : false
def sourceBuildVersion = '[RELEASE]' // Pulls the latest release

// Rebuild toggles; never build base unless explicitly required, always rebuild application.
def rebuildBaseImage = env.TAG_NAME == null ? true : false
def rebuildApplicationImage = env.TAG_NAME == null ? true : false
def buildGoogle = false

// Disable pr-merge builds; node-image pipeline doesn't use the PR images at all.
if ( env.BRANCH_NAME ==~ ~"^PR-\\d+" ) {
    currentBuild.result = 'SUCCESS'
    echo "Pull-Requests are not built for node-image-build; this is a no-op build."
    return
}

pipeline {
    agent {
        label "metal-gcp-builder-large"
    }

    options {
        buildDiscarder(logRotator(daysToKeepStr: "30", artifactDaysToKeepStr: "2"))
        timestamps()
        disableConcurrentBuilds()
    }

    environment {
        ARTIFACTS_DIRECTORY_BASE = "output-sles15-base"
        ARTIFACTS_DIRECTORY_APPLICATION = "output-application"
	NODE_IMAGE_BUILD="vendor/github.com/Cray-HPE/node-images"
        ISO = "SLE-15-SP3-Online-x86_64-GM-Media1.iso"
        ISO_URL = "https://artifactory.algol60.net/artifactory/os-images"
        IMAGE_REPO = "user-uan-images"
        NPROC = sh(returnStdout: true, script: "nproc").trim()
        NRAM = '8196'
        STABLE_BASE = "https://artifactory.algol60.net/artifactory/user-uan-images/stable"
        VERSION = setImageVersion(commitHashShort: GIT_COMMIT[0..6])
        SKIP_GCP_UPLOAD = "yes"
    }

    parameters {
        booleanParam(name: 'buildAndPublish', defaultValue: buildAndPublish, description: '(leave unchecked for; git-tags, main, and develop) Whether or not to actually rebuild and publish for a stable merge build job.')
        booleanParam(name: 'rebuildBaseImage', defaultValue: rebuildBaseImage, description: '(leave unchecked for; git-tags, main, and develop) Whether or not to build the base image; unchecked will pull latest STABLE base. (This overrides rebuildApplicationImage; if this is true, rebuildApplicationImage is bypassed.)')
        booleanParam(name: 'buildGoogle', defaultValue: buildGoogle, description: '(leave unchecked for; git-tags, main, and develop) Whether or not to build Google images for vshasta.)')
        booleanParam(name: 'rebuildApplicationImage', defaultValue: rebuildBaseImage, description: '(leave unchecked for; git-tags, main, and develop) Whether or not to build the application image; unchecked will pull latest STABLE application.')
        string(name: 'sourceProjectId', defaultValue: "artifactory-202004", description: 'The source Project ID for pulling Google images.')
    }

    stages {

        stage('Setup') {
            parallel {
                stage('autoinst.xml') {
                    when {
                        expression { env.TAG_NAME == null && (!(env.BRANCH_NAME ==~ promotionToken) || (env.BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
                        expression { params.rebuildBaseImage }
                    }
                    steps {
                        withCredentials([
                                string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD'),
                                string(credentialsId: 'sles15-registration-code', variable: 'SLES15_REGISTRATION_CODE'),
                        ]) {
                            sh '''
                                ./${NODE_IMAGE_BUILD}/scripts/setup.sh
                            '''
                        }
                    }
                }
                stage('Fetch ISO') {
                    when {
                        expression { env.TAG_NAME == null && (!(env.BRANCH_NAME ==~ promotionToken) || (env.BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
                        expression { params.rebuildBaseImage }
                    }
                    steps {
                        script {
                            dir(env.NODE_IMAGE_BUILD+'/iso') {
                                script {
                                    httpRequest(authentication: 'artifactory-algol60', outputFile: "${ISO}", responseHandle: 'NONE', url: "${env.ISO_URL}/${env.ISO}")
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Base Layers') {
		when {
			expression { env.TAG_NAME == null && (!(BRANCH_NAME ==~ promotionToken) || (BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
			expression { params.rebuildBaseImage }
		}
		steps {
			dir(env.NODE_IMAGE_BUILD) {
				withCredentials([
					string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD')
				]) {
					script {
                                                def arguments
                                                arguments = "-only=qemu.sles15-base -var 'source_iso_uri=iso/${env.ISO}' -var 'ssh_password=${SLES15_INITIAL_ROOT_PASSWORD}' -var 'cpus=${NPROC}' -var 'memory=${NRAM}' -var 'artifact_version=${VERSION}'"
                                                publishCsmImages.build(arguments, 'boxes/sles15-base/')
                                                publishCsmImages.prepareArtifacts(ARTIFACTS_DIRECTORY_BASE, VERSION)
                                                props = "build.number=${env.VERSION};build.url=${env.BUILD_URL};vcs.revision-short=${GIT_COMMIT[0..6]};build.source-artifact=${env.ISO_URL}/${env.ISO}"
                                                publishCsmImages(artifactoryRepo: IMAGE_REPO, pattern: ARTIFACTS_DIRECTORY_BASE, imageName: 'sles15-base', version: env.VERSION, props: props)
					}
				}
			}
		}
	}

        stage('Application Layers') {
            when {
                expression { env.TAG_NAME == null && (!(BRANCH_NAME ==~ promotionToken) || (BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
                expression { params.rebuildApplicationImage }
            }
            parallel {
                stage('Build Application') {
                    when {
                        expression { params.rebuildApplicationImage }
                    }
                    steps {
                        withCredentials([
                                string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD'),
                                usernamePassword(credentialsId: 'artifactory-algol60', usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_TOKEN'),
                        ]) {
                            script {

                                def base = "sles15-base"
                                def sourceImage = "${base}-${VERSION}"
                                def arguments
                                def props
                                def source = "${NODE_IMAGE_BUILD}/${ARTIFACTS_DIRECTORY_BASE}/${sourceImage}"

                                if (!params.rebuildBaseImage) {
                                    source = "${STABLE_BASE}/${base}/${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}/${base}-${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}"
                                    if (sourceBuildVersion != "[RELEASE]") {
                                        source = nodeImageHelpers.getArtifactorySourceArtifactFromId(source, sourceBuildVersion)
                                    }
                                    dir("${env.NODE_IMAGE_BUILD}/${env.ARTIFACTS_DIRECTORY_BASE}") {
                                        httpRequest(authentication: 'artifactory-algol60', outputFile: "${sourceImage}.qcow2", responseHandle: 'NONE', url: "${source}.qcow2")
                                    }
                                }

                                arguments = "-only=qemu.application -var 'source_iso_uri=${env.NODE_IMAGE_BUILD}/${env.ARTIFACTS_DIRECTORY_BASE}/${sourceImage}.qcow2' -var 'ssh_password=${SLES15_INITIAL_ROOT_PASSWORD}' -var 'artifactory_user=${ARTIFACTORY_USER}' -var 'artifactory_token=${ARTIFACTORY_TOKEN}' -var 'cpus=${NPROC}' -var 'memory=${NRAM}' -var 'artifact_version=${VERSION}'"
                                publishCsmImages.build(arguments, 'boxes/application/')
                                publishCsmImages.prepareArtifacts(ARTIFACTS_DIRECTORY_APPLICATION, VERSION)

                                props = "build.number=${env.VERSION};build.url=${env.BUILD_URL};vcs.revision-short=${GIT_COMMIT[0..6]};build.source-artifact=${source}"
                                publishCsmImages(artifactoryRepo: IMAGE_REPO, pattern: ARTIFACTS_DIRECTORY_APPLICATION, imageName: 'application', version: env.VERSION, props: props)
                            }
                        }
                    }
                }
            }
        }

        stage('Release') {
            when { tag "*" }
            steps {
                withCredentials([
                        usernamePassword(credentialsId: 'artifactory-algol60', usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_TOKEN'),
                        file(credentialsId: 'google-image-manager', variable: 'GOOGLE_CLOUD_SA_KEY')
                ]) {
                    script {
                        /*
                            Use a try/catch block to prevent sles15-base and pit from requiring an administrator to manually build a git-tag. This
                            manual process is tedious, and prone to mistakes, this way the Jenkins pipeline will always try to publish these layers.
                        */
                        try {
                            publishCsmImages.release('sles15-base', GIT_COMMIT[0..6], env.TAG_NAME, GOOGLE_CLOUD_SA_KEY)
                        } catch (err) {
                            echo err.getMessage()
                            echo 'The build attempted to publish a sles15-base image but none was found, this may or may not be expected.'
                        }
                        publishCsmImages.release('application', GIT_COMMIT[0..6], env.TAG_NAME, GOOGLE_CLOUD_SA_KEY)
                    }
                }
            }
        }
    }
}
